```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

// 문제: 특정 거리의 도시찾기
public class ActualProblem1 {

    public static class Node implements Comparable<Node> {
        private final int index;
        private final int distance;

        public Node(int index, int distance) {
            this.index = index;
            this.distance = distance;
        }

        public int getIndex() {
            return index;
        }

        public int getDistance() {
            return distance;
        }

        @Override
        public int compareTo(Node o) {
            if (distance < o.distance) {
                return -1;
            }
            return 1;
        }
    }

    private static final int INF = (int) 1e9;
    private static List<ArrayList<Node>> graph = new ArrayList<>();
    private static int[] dt = new int[300001];
    private static boolean[] visited = new boolean[300001];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); // 도시의 개수 (2 <= N <= 300,000)
        int M = sc.nextInt(); // 도로의 개수 (1 <= M <= 1,000,000)
        int K = sc.nextInt(); // 거리 정보 (1 <= K <= 300,000)
        int X = sc.nextInt(); // 특정한 도시 (1 <= X <= N)

        Arrays.fill(dt, INF);

        for (int i = 0; i <= N; i++) {
            graph.add(new ArrayList());
        }

        for (int i = 0; i < M; i++) {
            graph.get(sc.nextInt()).add(new Node(sc.nextInt(), 1));
        }

        dijkstra(X);

        List<Integer> answerList = IntStream.rangeClosed(1, N)
                .filter(index -> dt[index] == K)
                .sorted()
                .mapToObj(Integer::new)
                .collect(Collectors.toList());

        System.out.println(answerList.isEmpty() ? -1 : answerList.stream()
                .map(String::valueOf)
                .collect(Collectors.joining("\n")));
    }

    private static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(start, 0));
        dt[start] = 0;

        while (!pq.isEmpty()) {
            Node node = pq.poll();
            int now = node.getIndex();
            int distance = node.getDistance();

            if (dt[now] < distance) {
                continue;
            }

            int size = graph.get(now).size();
            for (int i = 0; i < size; i++) {
                Node k = graph.get(now).get(i);
                int cost = dt[now] + k.getDistance();

                if (cost < dt[k.getIndex()]) {
                    dt[k.getIndex()] = cost;
                    pq.offer(new Node(k.getIndex(), k.getDistance()));
                }
            }
        }
    }
}

```
