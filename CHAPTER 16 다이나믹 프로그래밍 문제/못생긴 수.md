# 나의 풀이

```java
import java.util.Scanner;
import java.util.stream.IntStream;

public class PracticalProblem5 {
    public static void main(String[] args) {
        int[] group = {1, 2, 3, 5};
        boolean[] dpTable = new boolean[1001];
        for (int i = 0; i < 4; i++) {
            dpTable[group[i]] = true;
        }

        for (int i = 1; i < 1001; i++) {
            if (dpTable[i]) {
                for (int j = 0; j < 4; j++) {
                    int index = i * group[j];
                    if (index <= 1000) {
                        dpTable[index] = true;
                    }
                }
            }
        }

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] answers = IntStream.range(1, 1001)
                .filter(index -> dpTable[index])
                .limit(n)
                .toArray();

        System.out.println(answers[n - 1]);
    }
}
```

아래와 같이 값을 갱신하는데, 중복 값도 많고 비효율적임. 
 ex) n = 15 일 때, 최소비용으로 15번째 값을 찾을 수 없음, 무조건 끝까지 완료하고 값을 찾아야 함 

```
1 2 3 5 
2 4 6 10 
3 6 9 15 
4 8 12 20 
5 10 15 25 
6 12 18 30 
8 16 24 40 
9 18 27 45 
10 20 30 50 
12 24 36 60 
15 30 45 75 
16 32 48 80 
18 36 54 90 
20 40 60 100 
24 48 72 120 
25 50 75 125 
27 54 81 135 
30 60 90 150 
32 64 96 160 
36 72 108 180 
40 80 120 200 
45 90 135 225 
48 96 144 240 
50 100 150 250 
54 108 162 270 
60 120 180 300 
64 128 192 320 
72 144 216 360 
75 150 225 375 
80 160 240 400 
81 162 243 405 
90 180 270 450 
96 192 288 480 
100 200 300 500 
108 216 324 540 
120 240 360 600 
125 250 375 625 
128 256 384 640 
135 270 405 675 
144 288 432 720 
150 300 450 750 
160 320 480 800 
162 324 486 810 
180 360 540 900 
192 384 576 960 
200 400 600 1000 
216 432 648 
225 450 675 
240 480 720 
243 486 729 
250 500 750 
256 512 768 
270 540 810 
288 576 864 
300 600 900 
320 640 960 
324 648 972 
360 720 
375 750 
384 768 
400 800 
405 810 
432 864 
450 900 
480 960 
486 972 
500 1000 
512 
540 
576 
600 
625 
640 
648 
675 
720 
729 
750 
768 
800 
810 
864 
900 
960 
972 
1000
```


# 답지 풀이 

```java
import java.util.*;

public class Main {
	
    static int n;
    static int[] ugly = new int[1000]; // 못생긴 수를 담기 위한 테이블 (1차원 DP 테이블)

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();

        // 2배, 3배, 5배를 위한 인덱스
        int i2 = 0, i3 = 0, i5 = 0;
        // 처음에 곱셈 값을 초기화
        int next2 = 2, next3 = 3, next5 = 5;

        ugly[0] = 1; // 첫 번째 못생긴 수는 1
        // 1부터 n까지의 못생긴 수들을 찾기
        for (int l = 1; l < n; l++) {
            // 가능한 곱셈 결과 중에서 가장 작은 수를 선택
            ugly[l] = Math.min(next2, Math.min(next3, next5));
            // 인덱스에 따라서 곱셈 결과를 증가
            if (ugly[l] == next2) {
                i2 += 1;
                next2 = ugly[i2] * 2;
            }
            if (ugly[l] == next3) {
                i3 += 1;
                next3 = ugly[i3] * 3;
            }
            if (ugly[l] == next5) {
                i5 += 1;
                next5 = ugly[i5] * 5;
            }
        }

        // n번째 못생긴 수를 출력
        System.out.println(ugly[n - 1]);
    }
}
```
